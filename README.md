# coda-schema-generator
Represents a Coda.io document as Go code structs and methods (see [# Generated code]() below).
Generated code is assumed to be used as part of a more complicated Go application that extend Coda.io capabilities.

It allows to use Coda document programmatically:
- Use autogenerated data structs reflecting tables and columns of the Coda document
- Load data from your document via Coda REST API
- Closely reflects Coda types, supports Lookups columns and allows to fetch data with deep loading of Lookup relations
- Refer to IDs of the Coda entities

Generated code very closely reflects the contents of the document -- tables, views, controls, formulas and provides a way to validate your app against current version of the Coda document.
This approach allows to be sure that no changes in Coda structure affect your app logic: your app will just fail to build unless the symbols from the generated code are used properly.

Additionally for each formula column there is a comment generated with the formula text.
This creates an orthogonal usage of the generated file -- finding/keeping records of usages of a certain column among other columns' formulas.

# Usage as standalone CLI app

## Generate schema for your Coda document
```
docker run --rm ghcr.io/artsafin/coda-schema-generator:v1.0.1 $CODA_TOKEN $CODA_DOCUMENT > internal/codaschema/codaschema.go
```

where:

- `$CODA_TOKEN` is an API token for Coda
- `$CODA_DOCUMENT` is a Coda document ID (`XXXXXXXXXX` part in the `https://coda.io/d/YOURHUMANDOCNAME_dXXXXXXXXXX` url)

# Usage as library

It's possible to include this package as library to have access to intermediate data and to have more control over generation.

```
go get -d github.com/artsafin/coda-schema-generator@latest
```

Use in your code:

```
import (
	...
	"github.com/artsafin/coda-schema-generator/schema"
	"github.com/artsafin/coda-schema-generator/generator"
	...
)

func main() {
    ...
    sch, err := schema.Get(opts)
	if err != nil {
		panic(err)
	}

	fmt.Println(sch.Tables.Items)
	
	err = generator.Generate("codaschema", "codaapi", sch, os.Stdout)
	if err != nil {
		panic(err)
	}
    ...
}
```

# Generated code

This is the most interesting part!

The output file will contain the following code:

## `codaschema.ID` variable and structs reflecting their IDs

There are tables, columns, formulas and controls type structs reflecting _metadata_ of the entities contained in the document.
They are useful only as formula comments holders and as helper types for populating the `codaschema.ID` (see next section)

### `codaschema.ID` variable

The `codaschema.ID` global variable contains an enumeration of all document entities with their IDs and human names.

This can be useful in it's own to refer to tables, table columns, etc by their human names without need of manual hardcoding of these IDs to your code.

For example if there is a `All Users` table in Coda with a `first name` and `last name` columns the generated code will include:

(note using  and `codaschema.ID.Table.Users.ID` instead of plain names or)

```
codaschema.ID.Table.AllUsers // Structure related to the [All Users] table

codaschema.ID.Table.AllUsers.ID // A string field containing ID of the [All Users] table for use API calls.
                                // Example value: "grid-RcSeMRomST"

codaschema.ID.Table.AllUsers.Name // A string field containing the name of the [All Users] table.
                                  // Example value: "All Users"

codaschema.ID.Table.AllUsers.Cols // Structure related to the [All Users] columns

codaschema.ID.Table.AllUsers.Cols.FirstName // Structure related to the [All Users].[first name] column

codaschema.ID.Table.AllUsers.Cols.FirstName.ID   // (see below)
codaschema.ID.Table.AllUsers.Cols.FirstName.Name // String fields containing ID and name of the column (similar to table)
```

Changing name of the table/column in Coda document and regenerating the code **will change** the schema -- thus bringing your app under chances of misusing of some `codaschema.ID.*` symbols.

The reason behind that is the difference of typical lifecycles of the Go application and Coda document:
it is very easy to quickly change a structure of the Coda document (thanks to the team behind the Coda!) and the way how it is used by other people but it's not so easy to keep the same pace of the changes on the Go app side.  

So this is considered a good practice as it encourages to keep the mental model of the document with the app code up to date.

## Data structs reflecting the document data model and their constructors

These structs reflect Coda tables/views and their columns as a normal Go struct.
The types of the struct fields will be as close to the column types of the source table as possible.

Additionally there will be a `New*` constructor generated per each struct that accepts a `Valuer` interface as a table row representation.

For example if there is a `All Users` table in Coda with a `first name` and `last name` columns there will be:

```
type Valuer interface {
	GetValue(key string) (value interface{}, ok bool)
}


type AllUsers struct {
    FirstName string
    LastName  string
    Location  LocationLookup // see more below on Lookup types
}

func NewAllUsers(row codaschema.Valuer) (codaschema.AllUsers, error) {
    ...
}

type Location struct {
    City string
    Zip  string
}

func NewLocation(row codaschema.Valuer) (codaschema.Location, error) {
    ...
}
```

These structs and constructors are useful on their own as they assume nothing about the way how the data has been loaded
and return clean strongly-typed structs containing the data ready to use.


### Type mapping

| Coda Type                 | Go Type                                                                        |
|---------------------------|--------------------------------------------------------------------------------|
| Date and Time, Date, Time | `time.Time`                                                                    |
| Scale                     | `uint8`                                                                        |
| Number, Slider            | `float64`                                                                      |
| Checkbox                  | `bool`                                                                         |
| Person, Reaction          | [`[]codaschema.Person`](blob/main/internal/templates/coda_types.go.tmpl)       |
| Image, Attachment         | [`[]codaschema.Attachment`](blob/main/internal/templates/coda_types.go.tmpl)   |
| Currency                  | [`codaschema.MonetaryAmount`](blob/main/internal/templates/coda_types.go.tmpl) |
| Lookup                    | `codaschema.<Table Name>Lookup` (see below more on Lookup types)               |
| (the rest)                | `string`                                                                       |

### Lookup types

##### Lookup type `<Table Name>Lookup`

For each table that is referenced by other tables in Lookups the generator yields `<Table Name>Lookup` types.
They represent a slice of references to rows in another table to which the Lookup in Coda is made.

Example of `<Table Name>Lookup` type:

```
type LocationLookup struct {
    Values []LocationRowRef
}
```

Lookup types also have handy methods to fetch the first row reference and the data of the first row reference.

##### Row reference type `<Table Name>RowRef`

A reference to a row is a `<Table Name>RowRef` type.
When the table data is loaded this struct contains data to the extent possible to extract from original request without doing extra HTTP requests.

The `<Table Name>RowRef` type also has a `Data` field with type of the target referenced table. It will be used by deep data loaders, see below.

Example of `<Table Name>RowRef`:

```
type LocationRowRef struct {
    Name  string
    RowID string
    Data  *Location
}
```


## Loading data into structs

coda-schema-generator generates functions for fetching table data into the generated structs using the https://github.com/artsafin/coda-go-client Coda client API library.


### CodaDocument type

Functions for loading all have the `CodaDocument` receiver which makes up an abstraction of the Coda Document and simplifies operations.

`CodaDocument` has a common `ListAllRows` method that can be used separately to build your own logic.
The signature is as follows:

```
func (d *CodaDocument) ListAllRows(ctx context.Context, tableID string, extraParams ...codaapi.ListRowsParam) ([]codaapi.Row, error)
```

Where:
- `codaapi.Row` type satisfies the `codaschema.Valuer` interface and therefore can be used with `New<Table Name>` data constructors
- `tableID` can be taken from `codaschema.ID.Tables.<Table Name>.ID`
- `codaapi.ListRowsParam` is a way to set the Query Parameters for the [ListRows operation](https://coda.io/developers/apis/v1#operation/listRows)

Example of usage:
```
    token := "..."
    docID := "..."
    doc, err := codaschema.NewCodaDocument("https://coda.io/apis/v1", token, docID)
    rows, err := doc.ListAllRows(
        ctx,
        codaschema.ID.Table.AllUsers.ID,
        codaapi.ListRows.SortBy(codaapi.RowsSortByNatural),
		codaapi.ListRows.Query(codaschema.ID.Table.AllUsers.Cols.FirstName.ID, "donald"),
	)
    if err != nil {
        ...
    }

    for _, row := range rows {
        item, err := NewAllUsers(&row)
        if err != nil {
            ...
        }
        fmt.Println(item)
    }
```


`CodaDocument` also contains functions specific to your document tables with two flavors:
- shallow loading of the data - i.e. without loading data into `codaschema.*Lookup` structs
- deep loading - with loading related lookups and putting the actual data into `codaschema.*Lookup` structs

### Shallow loading

**`List<TableName>` methods** -- load data is a slice of `<Table Name>` structs.

Example signature:

```
func (d *CodaDocument) ListAllUsers(ctx context.Context, extraParams ...codaapi.ListRowsParam) ([]codaschema.AllUsers, error)
```

**`MapOf<TableName>` methods** -- load data in a map indexed by Coda Row ID. Additionally since Go doesn't maintain an order of the map it returns an ordered slice of Row IDs. 

Example signature:

```
func (d *CodaDocument) MapOfAllUsers(ctx context.Context, extraParams ...codaapi.ListRowsParam) (map[RowID]AllUsers, []RowID, error)
```

`MapOf` methods were created to deal with lookup relations easier.
They are extensively used in deep loading functions.

### Deep loading

Deep loading methods require an already loaded map of data using `MapOf` methods.
They go through the rows and populate the `Data` field of the `RowRef` structs of all lookup values.

The method itself does not return anything, it just updates the map passed to the function.

Example signature:
```
func (doc *CodaDocument) LoadRelationsAllUsers(ctx context.Context, shallow map[RowID]codaschema.AllUsers, rels codaschema.Tables) (err error)
```

The last argument is a special `codaschema.Tables` struct that is used as enumeration of all tables in the document.
By this argument one can specify which kind of the Lookups to deep-load.

`LoadRelations<Table Name>` methods load _all related_ table data into an internal `CodaDocument` cache.

This approach has it's pros and cons:

- Pro: relation-loading is mostly a special routine in the main app when a lot of deeply-loaded entities are needed at once, therefore raising HIT/MISS cache ratio.
  Caching data of each kind of the referenced table at CodaDocument struct allows to optimize application by CPU and time (sacrificing RAM);
- Pro: every kind of data is loaded and parsed only once; even for further calls to other `LoadRelations<Table Name>` methods no extra requests will be made
- Cons: the volume of the referenced data may be high and it is not limited in any way. Unfortunately Coda API doesn't provide any way to fetch needed rows in batch by their IDs.
  Extra RAM usage can be an issue
- Cons: cache is not invalidated nor cleared; `CodaDocument` instance lifecycle should be as short as possible

# Example of application using codaschema

```
package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"github.com/artsafin/coda-data/codaschema"
	"github.com/artsafin/coda-go-client/codaapi"
	"github.com/artsafin/coda-schema-generator/dto"
	"github.com/artsafin/coda-schema-generator/generator"
	"github.com/artsafin/coda-schema-generator/schema"
	"os"
	"strings"
	"time"
)

func main() {
    token := os.Args[1]
    docID := os.Args[2]

    doc, err := codaschema.NewCodaDocument("https://coda.io/apis/v1", token, docID)
	if err != nil {
		panic(err)
	}

	ctx := context.Background() // On real apps it should include timeout at least

	usersMap, usersOrder, err := doc.MapOfAllUsers(
		ctx,
		codaapi.ListRows.SortBy(codaapi.RowsSortByNatural), // Returns the order that is seen in the browser 
	)
	if err != nil {
		panic(err)
	}
	err = doc.LoadRelationsAllUsers(ctx, usersMap, codaschema.Tables{
		Location: true,
	})
	if err != nil {
		panic(err)
	}

	for idx, rowid := range usersOrder {
		locationRef, ok := usersMap[rowid].Location.FirstRef()
		if !ok {
		    // Even if there is no first ref in Location lookup the locationRef will be an empty struct
		}

		fmt.Printf(
			"#%03d | %v: %20s | %v (%v) | %v %v\n",
			idx+1,
			locationRef.RowID,
			usersMap[rowid].Location.FirstData().City, // Or the same: locationRef.Data.City
			                                           // Or the same: usersMap[rowid].Location.Values[0].Data.City
			usersMap[rowid].FirstName,
			usersMap[rowid].LastName,
		)
	}
}
```

## Miscellaneous supporting functions and types

- `Valuer` interface that decouples an API library (`github.com/artsafin/coda-go-client`) from the generated code `codaschema`
- Various structs reflecting some Coda complex types: Person, MonetaryAmount, Attachment (ImageObject) and a Structured Value.
- Routines for parsing of basic internal types (strings, dates, numbers etc)
- Aggregate errors container

Mostly these are useful only for other `codaschema` code.

# Known shortcomings

- One may have security concerns about feeding the generator an API key exposing access to sensitive data
- There is no way to limit what is being generated yet - medium-sized document (~30 tables, ~20 views, ~20 canvas formulas) can yield ~10k LOC generated
- Mostly this project is targeted to work with Coda in readonly mode
- It doesn't include APIs to work with Packs
- The project itself has a minimal test coverage - I'm not yet certain on how to test generated code yet
